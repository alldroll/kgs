// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package dep

import (
	"database/sql"
	"errors"

	"github.com/google/wire"
	"github.com/short-d/app/fw"
	"github.com/short-d/app/modern/mdcli"
	"github.com/short-d/app/modern/mddb"
	"github.com/short-d/app/modern/mdenv"
	"github.com/short-d/app/modern/mdgrpc"
	"github.com/short-d/app/modern/mdio"
	"github.com/short-d/app/modern/mdlogger"
	"github.com/short-d/app/modern/mdruntime"
	"github.com/short-d/app/modern/mdservice"
	"github.com/short-d/app/modern/mdtimer"
	"github.com/short-d/app/modern/mdtracer"
	"github.com/short-d/kgs/app/adapter/db"
	"github.com/short-d/kgs/app/adapter/rpc"
	"github.com/short-d/kgs/app/usecase"
	"github.com/short-d/kgs/app/usecase/keys"
	"github.com/short-d/kgs/app/usecase/keys/gen"
	"github.com/short-d/kgs/app/usecase/repo"
	"github.com/short-d/kgs/app/usecase/transactional"
	"github.com/short-d/kgs/dep/provider"
)

// Injectors from wire.go:

func InitCommandFactory() fw.CommandFactory {
	cobraFactory := mdcli.NewCobraFactory()
	return cobraFactory
}

func InitDBConnector() fw.DBConnector {
	postgresConnector := mddb.NewPostgresConnector()
	return postgresConnector
}

func InitDBMigrationTool() fw.DBMigrationTool {
	postgresMigrationTool := mddb.NewPostgresMigrationTool()
	return postgresMigrationTool
}

func InitEnvironment() fw.Environment {
	goDotEnv := mdenv.NewGoDotEnv()
	return goDotEnv
}

func InitGRpcService(name string, logLevel fw.LogLevel, serviceEmailAddress provider.ServiceEmailAddress, sqlDB *sql.DB, securityPolicy fw.SecurityPolicy, sendGridAPIKey provider.SendGridAPIKey, templateRootDir provider.TemplateRootDir, cacheSize provider.CacheSize) (mdservice.Service, error) {
	stdOut := mdio.NewBuildInStdOut()
	timer := mdtimer.NewTimer()
	buildIn := mdruntime.NewBuildIn()
	local := mdlogger.NewLocal(name, logLevel, stdOut, timer, buildIn)
	template := provider.NewHTML(templateRootDir)
	availableKeyRepoFactory := availableKey()
	factorySQL := db.NewFactorySQL(sqlDB)
	v := gen.NewBase62()
	alphabet, err := gen.NewAlphabet(v)
	if err != nil {
		return mdservice.Service{}, err
	}
	producerPersist := keys.NewProducerPersist(availableKeyRepoFactory, factorySQL, alphabet, local)
	allocatedKeyRepoFactory := allocatedKey()
	consumerPersist := keys.NewConsumerPersist(availableKeyRepoFactory, allocatedKeyRepoFactory, factorySQL)
	consumerCached, err := provider.NewConsumer(cacheSize, consumerPersist)
	if err != nil {
		return mdservice.Service{}, err
	}
	sendGrid := provider.NewSendGrid(sendGridAPIKey)
	emailNotifier := provider.NewEmailNotifier(name, serviceEmailAddress, sendGrid)
	useCase := usecase.NewUseCase(local, template, producerPersist, consumerCached, emailNotifier)
	keyGenServer := rpc.NewKeyGenServer(useCase)
	kgsAPI := rpc.NewKgsAPI(keyGenServer)
	gRpc, err := mdgrpc.NewGRpc(kgsAPI, securityPolicy)
	if err != nil {
		return mdservice.Service{}, err
	}
	service := mdservice.New(name, gRpc, local)
	return service, nil
}

// wire.go:

func allocatedKey() keys.AllocatedKeyRepoFactory {
	return func(tx transactional.Transaction) (repo.AllocatedKey, error) {
		sqlTx, ok := tx.(*sql.Tx)

		if !ok {
			return nil, errors.New("allocatedKeyFactory expects sql.Tx")
		}

		return db.NewAllocatedKeyTransactional(sqlTx), nil
	}
}

func availableKey() keys.AvailableKeyRepoFactory {
	return func(tx transactional.Transaction) (repo.AvailableKey, error) {
		sqlTx, ok := tx.(*sql.Tx)

		if !ok {
			return nil, errors.New("availableKeyFactory expects sql.Tx")
		}

		return db.NewAvailableKeyTransactional(sqlTx), nil
	}
}

var observabilitySet = wire.NewSet(wire.Bind(new(fw.Logger), new(mdlogger.Local)), mdlogger.NewLocal, mdtracer.NewLocal)
